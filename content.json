{"meta":{"title":"神奇的战士","subtitle":"这个不辣～","description":"这个是描述","author":"神奇的战士","url":"http://wangshub.github.io"},"pages":[{"title":"分类","date":"2017-11-08T14:11:32.000Z","updated":"2017-12-15T06:04:40.543Z","comments":true,"path":"categories/index.html","permalink":"http://wangshub.github.io/categories/index.html","excerpt":"","text":""},{"title":"关于我","date":"2017-11-08T14:19:19.000Z","updated":"2017-12-15T06:04:40.543Z","comments":true,"path":"custom/index.html","permalink":"http://wangshub.github.io/custom/index.html","excerpt":"","text":""},{"title":"标签云","date":"2017-11-08T14:11:50.000Z","updated":"2017-12-15T06:04:40.543Z","comments":true,"path":"tags/index.html","permalink":"http://wangshub.github.io/tags/index.html","excerpt":"","text":""},{"title":"about","date":"2017-12-14T11:58:09.712Z","updated":"2017-12-14T11:58:09.712Z","comments":false,"path":"about/index.html","permalink":"http://wangshub.github.io/about/index.html","excerpt":"","text":"hello world"}],"posts":[{"title":"linux驱动器和分区的备份，使用dd命令示例","slug":"linux驱动器和分区的备份，使用dd命令示例","date":"2017-12-18T12:04:51.000Z","updated":"2017-12-18T12:06:29.958Z","comments":true,"path":"2017/12/18/linux驱动器和分区的备份，使用dd命令示例/","link":"","permalink":"http://wangshub.github.io/2017/12/18/linux驱动器和分区的备份，使用dd命令示例/","excerpt":"","text":"dd命令是Linux发行版非常简单的备份工具。 “dd”工具简单的拷贝标准输入到标准输出，在512字节块读取。dd 命令是Linux发行版非常简单的备份工具。该“dd”工具简单的拷贝标准输入到标准输出，在512字节块读取。 用dd命令，我们可以创建整盘，磁盘驱动器等备份，下面这篇文章将帮助你学习一些有用的“dd”命令。 1：创建现有分区备份以下命令将整个分区/dev/sdb1备份到/opt/sdb1.img文件。 # dd if=/dev/sdb1 of=/opt/sdb1.img 样本输出12316064937+0 records in16064937+0 records out8225247744 bytes (8.2 GB) copied, 123.319 s, 66.7 MB/s 2：恢复备份到其他分区上面 /opt/sdb1.img备份文件可以恢复到其他分区（/dev/sdb2），我们可以用以下命令恢复。 # dd if=/opt/sdb1.img of=/dev/sdb2 样本输出12316064937+0 records in16064937+0 records out8225247744 bytes (8.2 GB) copied, 197.688 s, 41.6 MB/s 现在，你可以看到的/dev/sdb2 是/dev/sdb1 的翻版。 3：创建与现有分区副本我们可以直接从现有的分区副本来分区。以下命令将创建的/dev/sdb1 到 /dev/sdb2 的副本。 # dd if=/dev/sdb1 of=/dev/sdb2 样本输出12316064937+0 records in16064937+0 records out8225247744 bytes (8.2 GB) copied, 221.431 s, 37.1 MB/s 4：创建现有的硬盘克隆以下命令将复制前446个字节这是MBR从第一个磁盘到第二个磁盘。这将创建第二个磁盘引导。 。 # dd if=/dev/sda of=/dev/sdb bs=446 count=1 1231+0 records in1+0 records out446 bytes (446 B) copied, 0.00174812 s, 255 kB/s 现在确保在/dev/sdb的匹配为/dev/sda的分区。一旦做到这一点，您可以使用复制每个分区： # dd if=/dev/sda1 of=/dev/sdb1 # dd if=/dev/sda2 of=/dev/sdb2 5：备份和恢复的MBR镜像文件创建使用以下命令MBR的镜像文件的备份。 # dd if=/dev/sda of=/opt/backup-mbr-sda.img bs=512 count=1 示例输出1231+0 records in1+0 records out512 bytes (512 B) copied, 0.0115243 s, 44.4 kB/s 接下来的步骤是MBR恢复到不同的磁盘，使用下面的命令来做到这一点。 # dd if=/opt/backup-mbr-sda.img of=/dev/sdb bs=446 count=1","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"http://wangshub.github.io/tags/linux/"}]},{"title":"python数字图像处理-图像噪声与去噪算法","slug":"python数字图像处理-图像噪声与去噪算法","date":"2017-12-16T09:19:29.000Z","updated":"2017-12-16T09:33:26.412Z","comments":true,"path":"2017/12/16/python数字图像处理-图像噪声与去噪算法/","link":"","permalink":"http://wangshub.github.io/2017/12/16/python数字图像处理-图像噪声与去噪算法/","excerpt":"","text":"python数字图像处理-图像噪声与去噪算法 figure_1.png 图像噪声椒盐噪声概述： 椒盐噪声（salt &amp; pepper noise）是数字图像的一个常见噪声，所谓椒盐，椒就是黑，盐就是白，椒盐噪声就是在图像上随机出现黑色白色的像素。椒盐噪声是一种因为信号脉冲强度引起的噪声，产生该噪声的算法也比较简单。 给一副数字图像加上椒盐噪声的步骤如下： 指定信噪比 SNR （其取值范围在[0, 1]之间） 计算总像素数目 SP， 得到要加噪的像素数目 NP = SP * (1-SNR) 随机获取要加噪的每个像素位置P（i, j） 指定像素值为255或者0。 重复3,4两个步骤完成所有像素的NP个像素 输出加噪以后的图像 高斯噪声概述： 加性高斯白噪声(Additive white Gaussian noise，AWGN)在通信领域中指的是一种功率谱函数是常数(即白噪声), 且幅度服从高斯分布的噪声信号. 这类噪声通常来自感光元件, 且无法避免. 去噪算法中值滤波概述： 中值滤波是一种非线性空间滤波器, 它的响应基于图像滤波器包围的图像区域中像素的统计排序, 然后由统计排序结果的值代替中心像素的值. 中值滤波器将其像素邻域内的灰度中值代替代替该像素的值. 中值滤波器的使用非常普遍, 这是因为对于一定类型的随机噪声, 它提供了一种优秀的去噪能力, 比小尺寸的均值滤波器模糊程度明显要低. 中值滤波器对处理脉冲噪声(也称椒盐噪声)非常有效, 因为该噪声是以黑白点叠加在图像上面的. 与中值滤波相似的还有最大值滤波器和最小值滤波器. 均值滤波概述： 均值滤波器的输出是包含在滤波掩模领域内像素的简单平均值. 均值滤波器最常用的目的就是减噪. 然而, 图像边缘也是由图像灰度尖锐变化带来的特性, 所以均值滤波还是存在不希望的边缘模糊负面效应. 均值滤波还有一个重要应用, 为了对感兴趣的图像得出一个粗略描述而模糊一幅图像. 这样, 那些较小物体的强度与背景揉合在一起了, 较大物体变得像斑点而易于检测.掩模的大小由即将融入背景中的物体尺寸决定. 代码见https://github.com/wangshub/python-image-process","categories":[],"tags":[{"name":"python","slug":"python","permalink":"http://wangshub.github.io/tags/python/"},{"name":"algorithm","slug":"algorithm","permalink":"http://wangshub.github.io/tags/algorithm/"},{"name":"image","slug":"image","permalink":"http://wangshub.github.io/tags/image/"}]},{"title":"python数字图像处理-图像的基本结构和基础知识","slug":"python数字图像处理-图像的基本结构和基础知识","date":"2017-12-16T09:10:39.000Z","updated":"2017-12-16T09:18:39.452Z","comments":true,"path":"2017/12/16/python数字图像处理-图像的基本结构和基础知识/","link":"","permalink":"http://wangshub.github.io/2017/12/16/python数字图像处理-图像的基本结构和基础知识/","excerpt":"","text":"数字图像处理-图像的基本结构和基础知识 LenaRGB.bmp 一、python实现BMP图像的读取和显示BMP文件格式，又称为Bitmap（位图）或是DIB(Device-Independent Device，设备无关位图)，是Windows系统中广泛使用的图像文件格式。由于它可以不作任何变换地保存图像像素域的数据，因此成为我们取得RAW数据的重要来源。Windows的图形用户界面（graphical user interfaces）也在它的内建图像子系统GDI中对BMP格式提供了支持。 BMP文件的数据按照从文件头开始的先后顺序分为四个部分： bmp文件头(bmp file header) ：提供文件的格式、大小等信息 位图信息头(bitmap information)：提供图像数据的尺寸、位平面数、压缩方式、颜色索引等信息 调色板(color palette)：可选，如使用索引来表示图像，调色板就是索引与其对应的颜色的映射表 位图数据(bitmap data)：就是图像数据 参考链接https://zh.wikipedia.org/wiki/BMP 二、python统计图像的直方图图像直方图（英语：Image Histogram）是用以表示数字图像中亮度分布的直方图，标绘了图像中每个亮度值的像素数。可以借助观察该直方图了解需要如何调整亮度分布。这种直方图中，横坐标的左侧为纯黑、较暗的区域，而右侧为较亮、纯白的区域。因此，一张较暗图片的图像直方图中的数据多集中于左侧和中间部分；而整体明亮、只有少量阴影的图像则相反。很多数码相机提供图像直方图功能，拍摄者可以通过观察图像直方图了解到当前图像是否过分曝光或者曝光不足。计算机视觉领域常借助图像直方图来实现图像的二值化 2 统计直方图.png 参考链接https://zh.wikipedia.org/wiki/%E7%9B%B4%E6%96%B9%E5%9B%BE#%E5%9B%BE%E5%83%8F%E7%9B%B4%E6%96%B9%E5%9B%BE 三、RGB、YIQ、HSI、XYZ颜色空间YIQYIQ色彩空间通常被北美的电视系统所采用，属于NTSC（National Television Standards Committee）系统。这里Y不是指黄色，而是指颜色的明视度（Luminance），即亮度（Brightness）。其实Y就是图像的灰度值（Gray value），而I和Q则是指色调（Chrominance），即描述图像色彩及饱和度的属性。在YIQ系统中，Y分量代表图像的亮度信息，I、Q两个分量则携带颜色信息，I分量代表从橙色到青色的颜色变化，而Q分量则代表从紫色到黄绿色的颜色变化。 NTSC制为了进一步压缩色度带宽，用色差信号I,Q来代替U,V。若采用U,V色差信号，则色度、亮度信号的共频带部分极大，低端不共频带的亮度信号带宽很小，亮、色干扰大。将彩色图像从RGB转换到YIQ色彩空间，可以把彩色图像中的亮度信息与色度信息分开，分别独立进行处理。 RGB和YIQ的对应关系用下面的方程式表示：123Y=0.299R+0.587G+0.114BI=0.596R-0.274G-0.322BQ=0.211R-0.523G+0.312B 3 YIQ分量.png HSI 色调H（Hue）：与光波的波长有关，它表示人的感官对不同颜色的感受，如红色、绿色、蓝色等，它也可表示一定范围的颜色，如暖色、冷色等。 饱和度S（Saturation）：表示颜色的纯度，纯光谱色是完全饱和的，加入白光会稀释饱和度。饱和度越大，颜色看起来就会越鲜艳，反之亦然。 亮度I（Intensity）：对应成像亮度和图像灰度，是颜色的明亮程度。若将RGB单位立方体沿主对角线进行投影，可得到六边形，这样，原来沿主对角线的灰色都投影到中心白色点，而红色点（1，0，0）则位于右边的角上，绿色点（0，1，0）位于左上角，蓝色点（0，0，1）则位于左下角。 HSI颜色模型的双六棱锥表示，I是强度轴，色调H的角度范围为[0，2π]，其中，纯红色的角度为0，纯绿色的角度为2π/3，纯蓝色的角度为4π/3。饱和度S是颜色空间任一点距I轴的距离。当然，若用圆表示RGB模型的投影，则HSI色度空间为双圆锥3D表示。 注意： 当强度I=0时，色调H、饱和度S无定义；当S=0时，色调H无定义。HSI模型也可用圆柱来表示，如图9-5所示。若将其展开，并按图9-6进行定义，可得到HSI调色板。 HSI_Formula.jpg 5 HSI分量.png XYZ国际照明委员会(CIE)在进行了大量正常人视觉测量和统计,1931年建立了”标准色度观察者”， 从而奠定了现代CIE标准色度学的定量基础。由于”标准色度观察者”用来标定光谱色时出现负 刺激值，计算不便，也不易理解，因此1931年CIE在RGB系统基础上，改用三个假想的原色X、Y、 Z建立了一个新的色度系统。将它匹配等能光谱的三刺激值，定名为”CIE1931 标准色度观察者 光谱三刺激值”，简称为”CIE1931标准色度观察者”。这一系统叫做”CIE1931标准色度系统”或称为” 2° 视场XYZ色度系统”。CIEXYZ颜色空间稍加变换就可得到Yxy色彩空间，其中Y取三刺激值中Y的值， 表示亮度，x、y反映颜色的色度特性。定义如下：在色彩管理中，选择与设备无关的颜色空间是 十分重要的，与设备无关的颜色空间由国际照明委员会(CIE)制定，包括CIEXYZ和CIELAB两个标准。 它们包含了人眼所能辨别的全部颜色。而且，CIEYxy测色制的建立给定量的确定颜色创造了条件。 但是，在这一空间中，两种不同颜色之间的距离值并不能正确地反映人们色彩感觉差别的大小， 也就是说在CIEYxy色厦图中，在 不同的位置不同方向上颜色的宽容量是不同的，这就是Yxy颜色空间 的不均匀性。这一缺陷的存在，使得在Yxy及XYZ空间不能直观地评价颜色。 xyz.jpg 6 XYZ分量.png 四、python代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148#encoding: utf-8import numpy as npfrom PIL import Imageimport matplotlib.pyplot as pltimport mathdef show_bmp(img): # BMP 的读取与显示 plt.figure(\"LenaRGB.bmp\") plt.title(\"LenaRGB.bmp\") plt.imshow(img) plt.show()def show_hist(img): # 直方图 plt.figure(\"Lena hist\") plt.title('Lena hist figure') arr = img.flatten() n, bins, patches = plt.hist(arr, bins=256, normed=1, facecolor='green', alpha=0.75) plt.show()def show_rgb(img): # 显示RGB图像 plt.subplot(221) plt.title('orignal') plt.imshow(img) plt.subplot(222) plt.title('R') plt.imshow(img[:, :, 0], cmap='gray') plt.subplot(223) plt.title('G') plt.imshow(img[:, :, 1], cmap='gray') plt.subplot(224) plt.title('B') plt.imshow(img[:, :, 2], cmap='gray') plt.show()def shou_yiq(img): # 显示YIQ分量 R = np.mat(img[:, :, 0]) G = np.mat(img[:, :, 1]) B = np.mat(img[:, :, 2]) # aH = np.array([(0.299, 0.587, 0.114), # (0.596, -0.274, -0.322), # (0.211, -0.523, 0.312)]) Y = 0.299 * R + 0.587 * G + 0.114 * B I = 0.596 * R - 0.274 * G - 0.322 * B Q = 0.211 * R - 0.523 * G - 0.312 * B plt.subplot(221) plt.title('orignal') plt.imshow(img) plt.subplot(222) plt.title('Y') plt.imshow(Y, cmap='gray') plt.subplot(223) plt.title('I') plt.imshow(I, cmap='gray') plt.subplot(224) plt.title('Q') plt.imshow(Q, cmap='gray') plt.show() # YIQ = def show_xyz(img): # 显示YIQ分量 R = np.mat(img[:, :, 0]) G = np.mat(img[:, :, 1]) B = np.mat(img[:, :, 2]) # aH = np.array([(0.299, 0.587, 0.114), # (0.596, -0.274, -0.322), # (0.211, -0.523, 0.312)]) X = 0.490 * R + 0.310 * G + 0.200 * B Y = 0.177 * R + 0.813 * G + 0.011 * B Z = 0.000 * R + 0.010 * G + 0.990 * B plt.subplot(221) plt.title('orignal') plt.imshow(img) plt.subplot(222) plt.title('X') plt.imshow(X, cmap='gray') plt.subplot(223) plt.title('Y') plt.imshow(Y, cmap='gray') plt.subplot(224) plt.title('Z') plt.imshow(Z, cmap='gray') plt.show()def show_hsi(img): rows, cols, dims = img.shape R = np.mat(img[:, :, 0]) G = np.mat(img[:, :, 1]) B = np.mat(img[:, :, 2]) I = (R + G + B) / 3 E = np.mat(np.ones([rows, cols])) minRGB = np.mat(img.min(2)) lv = 3 * E / (R + G + B) S = E - np.multiply(lv, minRGB) # S = np.mat(np.zeros([rows, cols])) # for i in range(rows): # for j in range(cols): # S[i, j] = 1 - 3/(R[i, j] + G[i, j] + B[i, j]) * min([R[i, j], G[i, j], B[i, j]]) H = np.mat(np.zeros([rows, cols])) for i in range(rows): for j in range(cols): up = (R[i, j] - G[i, j] + R[i, j] - B[i, j]) / 2 down = (R[i, j] - G[i, j])**2 + (R[i, j] - B[i, j]) * (G[i, j] - B[i, j])**0.5 H[i, j] = math.acos(up / down) plt.subplot(221) plt.title('orignal') plt.imshow(img) plt.subplot(222) plt.title('I') plt.imshow(I, cmap='gray') plt.subplot(223) plt.title('S') plt.imshow(S, cmap='gray') plt.subplot(224) plt.title('H') plt.imshow(H, cmap='gray') plt.show()def main(): img = np.array(Image.open('/home/sun/Desktop/PycharmProjects/Digital_image_process_lxk/lab1/LenaRGB.bmp')) rows, cols, dims = img.shape print img.shape print img.dtype print img.size print type(img) # show_bmp(img) # show_hist(img) # show_rgb(img) # shou_yiq(img) # show_hsi(img) # show_xyz(img)if __name__ == '__main__': main()","categories":[],"tags":[{"name":"python","slug":"python","permalink":"http://wangshub.github.io/tags/python/"},{"name":"algorithm","slug":"algorithm","permalink":"http://wangshub.github.io/tags/algorithm/"},{"name":"image","slug":"image","permalink":"http://wangshub.github.io/tags/image/"}]},{"title":"python：将图片转换成excel文档","slug":"image-to-excel","date":"2017-12-14T13:28:12.000Z","updated":"2017-12-14T13:37:39.573Z","comments":true,"path":"2017/12/14/image-to-excel/","link":"","permalink":"http://wangshub.github.io/2017/12/14/image-to-excel/","excerpt":"","text":"python：将图片转换成excel文档实现步骤 读取图像，获取图像每个像素点的RGB值； 根据每个像素点的RGB值设置excel每个方格的颜色值； 根据像素点的坐标，写入excel文件； 保存退出； 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061from PIL import Imageimport numpy as npimport timeimport matplotlib.pyplot as pltimport xlsxwriterdef get_xy(row, col): table = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' num1 = col / 26 num2 = col % 26 # print num1, num2 if num1 == 0: return table[num2 - 1] + str(row) else: return table[num1-1] + table[num2 - 1] + str(row)def main(): img = np.array(Image.open('whale.jpeg')) # plt.figure(\"whale\") # plt.imshow(img) # plt.show() rows, cols, dims = img.shape print img.shape print img.dtype print img.size print type(img) # print img[188, 188, 0] excel = xlsxwriter.Workbook('image_excel.xlsx') cellformat = excel.add_format(&#123;'bg_color': '#123456', 'font_color': '#654321'&#125;) worksheet1 = excel.add_worksheet() data = [] color = [''] * cols cellcolor = \"\" for i in range(rows): for j in range(cols): # print hex(img[i, j, 0]), hex(img[i, j, 1]), hex(img[i, j, 2]) cellcolor = (hex(img[i, j, 0]) + hex(img[i, j, 1]) + hex(img[i, j, 2])).replace('0x', '') # print cellcolor cellformat = excel.add_format(&#123;'bg_color': '#'+cellcolor, 'font_color': '#'+cellcolor&#125;) # cellformat = excel.add_format(&#123;'bg_color': '#C6EFCE', # 'font_color': '#006100'&#125;) worksheet1.conditional_format(get_xy(i, j), &#123;'type': 'cell', 'criteria': '&lt;', 'value': 50, 'format': cellformat&#125;) # data.append(data_row) excel.close() if __name__ == '__main__': main() # print get_xy(133, 27)","categories":[],"tags":[{"name":"python","slug":"python","permalink":"http://wangshub.github.io/tags/python/"}]},{"title":"python check hosts update","slug":"python-check-hosts-update","date":"2017-07-20T14:33:15.000Z","updated":"2017-07-20T14:45:58.984Z","comments":true,"path":"2017/07/20/python-check-hosts-update/","link":"","permalink":"http://wangshub.github.io/2017/07/20/python-check-hosts-update/","excerpt":"","text":"用Python检查 hosts 更新最近各种代理纷纷关闭，常见的翻墙方式就剩lantern和更改hosts的方式依旧坚挺，关注了一些更新hosts的git仓库，但是又不想登录网页查看原作者是否有更新。所以这种苦力活就让Python干好了。 hosts地址_hostsinfo.py1hosts_source = [\"https://raw.githubusercontent.com/racaljk/hosts/master/hosts\"] 检查hosts是否有更新_checkhosts.py1234567891011121314151617181920212223242526272829303132333435363738394041424344import urllib2from .hosts_info import *import osimport filecmpdef hosts_download(): if os.path.exists('hosts'): hosts_name = 'hosts_new' else: hosts_name = 'hosts' # todo: overtime detection f = urllib2.urlopen(hosts_source[0]) print \"downloading hosts\" with open(hosts_name, \"wb\") as code: code.write(f.read())def is_hosts_new(): hosts_download() if not os.path.exists('hosts'): print 'oops, hosts not exists' return -1 elif os.path.exists('hosts') and (not os.path.exists('hosts_new')): print 'first run, only one hosts file' return True elif os.path.exists('hosts') and (os.path.exists('hosts_new')): print 'compare hosts &amp; hosts_new' diff_status = filecmp.cmp('hosts', 'hosts_new') if diff_status: print 'same file' os.remove('hosts_new') return False else: print 'diff file' os.remove('hosts') os.rename('hosts_new', \"hosts\") return True else: return -1 主程序调用main.py1234567from check_hosts.check_hosts import *diff_status = is_hosts_new()if diff_status: print \"new hosts !\"else: print 'code: ',diff_status","categories":[{"name":"Python","slug":"Python","permalink":"http://wangshub.github.io/categories/Python/"},{"name":"VPN","slug":"Python/VPN","permalink":"http://wangshub.github.io/categories/Python/VPN/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://wangshub.github.io/tags/Python/"},{"name":"VPN","slug":"VPN","permalink":"http://wangshub.github.io/tags/VPN/"}]},{"title":"python mail sender","slug":"python-mail-sender","date":"2017-07-20T14:22:06.000Z","updated":"2017-07-20T14:30:11.387Z","comments":true,"path":"2017/07/20/python-mail-sender/","link":"","permalink":"http://wangshub.github.io/2017/07/20/python-mail-sender/","excerpt":"","text":"python 发送邮件配置服务器和邮箱 mail_info.py123456mail_host = 'smtp.yeah.net'mail_user = 'mail_name'mail_pass = 'mail_password'sender = 'mail_name@yeah.net'receivers = ['target@mail.com'] 发送邮件 mail_trans.py1234567891011121314151617181920212223from .mail_info import *import smtplibfrom email.mime.text import MIMETextdef mail_text_send(title, text): message = MIMEText(text, 'plain', 'utf-8') message['Subject'] = title message['From'] = sender message['To'] = receivers[0] try: smtpObj = smtplib.SMTP() # connect host smtpObj.connect(mail_host, 25) # login host smtpObj.login(mail_user, mail_pass) # send smtpObj.sendmail(sender, receivers, message.as_string()) # quit smtpObj.quit() return True except smtplib.SMTPException as e: return False 主程序调用 main.py12from mail_trans import *mail_text_send('title', 'hello world!')","categories":[{"name":"Python","slug":"Python","permalink":"http://wangshub.github.io/categories/Python/"},{"name":"Code","slug":"Python/Code","permalink":"http://wangshub.github.io/categories/Python/Code/"},{"name":"Mail","slug":"Python/Code/Mail","permalink":"http://wangshub.github.io/categories/Python/Code/Mail/"}],"tags":[{"name":"Code","slug":"Code","permalink":"http://wangshub.github.io/tags/Code/"},{"name":"Python","slug":"Python","permalink":"http://wangshub.github.io/tags/Python/"},{"name":"Mail","slug":"Mail","permalink":"http://wangshub.github.io/tags/Mail/"}]},{"title":"使用python备份博客图床图片","slug":"use-python-to-backup-markdown-images","date":"2017-06-05T15:09:29.000Z","updated":"2017-06-05T15:31:18.000Z","comments":true,"path":"2017/06/05/use-python-to-backup-markdown-images/","link":"","permalink":"http://wangshub.github.io/2017/06/05/use-python-to-backup-markdown-images/","excerpt":"","text":"说明最近在写markdown文档的过程中,经常需要插入一些图片.因为托管博客的服务器空间有限,所以上传图片到图床再插入到markdown中.有时候又插入网上的图片,这些图片随时可能失效.导致我的博客网站显示图片错误.所以花了一点时间,用python 正则匹配 markdown中图片链接,然后下载图片保存到本地文件夹img中.这样就不用担心图片失效啦,当我找到稳定的图床,可以随时把这些图片再上传更新,美滋滋~~~ 功能 .md文件自动搜索 正则匹配图片链接 爬取图片内容 保存文本到本地 步骤读取文件 =&gt; 正则匹配 =&gt; 图片下载 =&gt; 保存本地 python代码详细见我的github地址: www.github.com/wangshub 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051# coding=utf-8import sysimport osimport reimport requestsimport urllibimport urllib2def search(path, word): for filename in os.listdir(path): fp = os.path.join(path, filename) if os.path.isfile(fp) and word in filename: print fp download(str(fp)) elif os.path.isdir(fp): search(fp, word)def download(file_path): # filename = \"test\" name = file_path.split(u\"/\") filename = name[-1] f_md = open(file_path) # all text of md file text = f_md.read().decode('utf-8') # regex img_reg = r'\\!&#123;1&#125;\\[(.*?)\\]\\((.*?)\\)' result = re.findall('!\\[(.*)\\]\\((.*)\\)', text) for i in range(len(result)): img_quote = result[i][0] img_url = result[i][1] # download img request = urllib2.Request(img_url) response = urllib2.urlopen(request) img_contents = response.read() # img name spell urlname = img_url.split(u\"/\") img_name = filename + '_' + \\ str(i) + '_' + img_quote + str(urlname[len(urlname) - 1]) print img_name, '~~~', img_url # write to file f_img = open('img/' + img_name, 'wb') f_img.write(img_contents) f_img.close() f_md.close()search(sys.argv[1], '.md') 食用方法python md_image_bacup.py /path/to/your/file/ 作者 Author : WangSongE-mail : easternslope@yeah.net","categories":[{"name":"python","slug":"python","permalink":"http://wangshub.github.io/categories/python/"},{"name":"markdown","slug":"python/markdown","permalink":"http://wangshub.github.io/categories/python/markdown/"},{"name":"code","slug":"python/markdown/code","permalink":"http://wangshub.github.io/categories/python/markdown/code/"}],"tags":[{"name":"python","slug":"python","permalink":"http://wangshub.github.io/tags/python/"},{"name":"code","slug":"code","permalink":"http://wangshub.github.io/tags/code/"},{"name":"markdown","slug":"markdown","permalink":"http://wangshub.github.io/tags/markdown/"}]},{"title":"从机sshfs访问主机文件系统","slug":"sshfs-mount-net-disk","date":"2017-05-31T13:16:00.000Z","updated":"2017-05-31T14:57:30.000Z","comments":true,"path":"2017/05/31/sshfs-mount-net-disk/","link":"","permalink":"http://wangshub.github.io/2017/05/31/sshfs-mount-net-disk/","excerpt":"","text":"说明需要在PC主机(Linux)上编写代码,每次都要将代码拷贝到从机(Linux)上编译运行程序.这里用到scp命令 scp -r /主机/文件 从机名@192.168.x.x:从机目录/.利用sshfs可以直接在从机进行编译,省略拷贝步骤. 系统结构框图Linux 主机 &lt;=====&gt; Linux 从机 操作步骤 主机 sudo apt-get install openssh-server ifconfig -a获取局域网内 IP地址 从机 sudo apt-get install sshfs sshfs -o idmap=user -o reconnect host_name@192.168.20.236:/path/to/your/workspace /path/to/your/workspace 现在可以从从机开心地访问主机文件了 author : Wangsongmail : easternslope@yeah.net","categories":[{"name":"linux","slug":"linux","permalink":"http://wangshub.github.io/categories/linux/"},{"name":"tool","slug":"linux/tool","permalink":"http://wangshub.github.io/categories/linux/tool/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://wangshub.github.io/tags/linux/"},{"name":"tool","slug":"tool","permalink":"http://wangshub.github.io/tags/tool/"}]},{"title":"python 数据结构之二叉搜索树","slug":"python-data-structure-BST","date":"2017-05-29T15:06:12.000Z","updated":"2017-07-13T03:28:54.652Z","comments":true,"path":"2017/05/29/python-data-structure-BST/","link":"","permalink":"http://wangshub.github.io/2017/05/29/python-data-structure-BST/","excerpt":"","text":"二叉搜索树定义一颗二叉搜索树是以二叉树来组织的,每个节点除了 Key 还包括 左孩子, 右孩子, 父节点 等信息. BST满足限制条件: 对于任意节点的X,他的 左子树中关键字最大值&lt;=X.key , 右子树关键字最小值&gt;=X.key 这个关系表示如下 二叉 根据上图定义,一个二叉搜索树的例子是 二叉树操作 查询 插入 删除 查询(搜索)二叉树搜索采用递归的方式来进行查询,根据二叉搜索树的定义: 左子树存储小值, 右子树存储大值,一个完整的二叉搜索示意图如下 可以写成 伪代码 1234567TREE-SEARCH(x, k) if x == NULL or k == x.key return x if k &lt; x.key return TREE-SEARCH(x.left) if k &gt; x.key return TREE-SEARCH(x.right) 转换成python代码 12345678910111213141516171819def _get(self, key, node): if node is None: return None if key &lt; node.key: return self._get(key, node.left) elif key &gt; node.key: return self._get(key, node.right) else: return node.valdef get(self, key): \"\"\" Return the value paired with 'key' Worst Case Complexity: O(N) Balanced Tree Complexity: O(lg N) \"\"\" return self._get(key, self.root) 插入插入和删除比查询呢稍微复杂一些,因为该操作会引起二叉搜索树的大小变化,会改变动态集合的结构.插入呢又比删除稍微容易实现.插入分为两部 查询插入节点 改变目标节点附近的数据结构 插入过程示意图如下 相应的伪代码如下, 输入节点 z , z.key = v, z.left = NULL, z.right = NULL. 12345678910111213141516TREE-INSERT(T, x) y = NULL x = T.root # 从根节点开始 while x != NULL y = x # 保存上一节点 if z.key &lt; x.key # 往左 x = x.left else # 往右 x = x.right z.p = y # 父节点 if y == NULL # tree T 为空 T.root = z else if z.key &lt; y.key y.left = z else y.right = z 程序的运行复杂度取决于二叉树的形状 插入的运行时间取决于二叉搜索树的高度h,程序的运行时间O(h) ,所以二叉树形状的好坏直接影响算法的运行时间. python代码实现为 123456789101112131415161718192021222324252627def _put(self, key, val, node): # If we hit the end of a branch, create a new node if node is None: return Node(key, val) # Follow left branch if key &lt; node.key: node.left = self._put(key, val, node.left) # Follow right branch elif key &gt; node.key: node.right = self._put(key, val, node.right) # Overwrite value else: node.val = val node.size_of_subtree = self._size(node.left) + self._size(node.right)+1 return nodedef put(self, key, val): \"\"\" Add a new key-value pair. Worst Case Complexity: O(N) Balanced Tree Complexity: O(lg N) \"\"\" self.root = self._put(key, val, self.root) 删除删除总共分为三种情况: 如果删除节点x没有孩子,直接删除即可; 如果删除节点x有1个孩子,用孩子替换该节点位置; 如果删除节点x有2个孩子, 这个情况有些复杂.关键是要找到节点 x的继承者 . 节点z的继承者在节点z的右子树中有最小的关键值.这种情况下的操作分为下面步骤: 输入待删除的节点x 和 二叉搜索树T. 在节点x的右子树开始搜索:往右再往左找到最小值节点H; H右孩子为H的父节点, H的左孩子为X的左孩子; 示意图如下,应该一目了然: ](http://algs4.cs.princeton.edu/32bst/images/bst-deletemin.png) ![ 根据上面的描述,删除的伪代码可以分为两部分: 为了移动子树, 用一棵子树替换一棵子树,并成为双亲的孩子节点. 123456789TRANSPLANT(T, u, v)if u.p == NULLT.root = velse if u = u.p.leftu.p.left = velse u.p.right = vif v!= NULLv.p = u.p 根据第一步完成二叉搜索树的删除过程: 1234567891011121314TREE-DELETE(T, z)if z.left = NULLTRANSPLANT(T, z, z.right)else if (z.right == NULL)TRANSPLANT(T, z, z.left)elsey = TREE-MINIMUM(z.right)if y.p != zTRANSPLANT(T, y, y.right)y.right = z.righty.right.p = yTRANSPLANT(T, z, y)y.left = z.lefty.left.p = y 用python 实现如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748def _delete(self, key, node): if node is None: return None if key &lt; node.key: node.left = self._delete(key, node.left) elif key &gt; node.key: node.right = self._delete(key, node.right) else: if node.right is None: return node.left elif node.left is None: return node.right else: old_node = node node = self._ceiling_node(key, node.right) node.right = self._delete_min(old_node.right) node.left = old_node.left node.size_of_subtree = self._size(node.left) + self._size(node.right)+1 return nodedef _delete_min(self, node): if node.left is None: return node.right node.left = self._delete_min(node.left) node.size_of_subtree = self._size(node.left) + self._size(node.right)+1 return nodedef _ceiling_node(self, key, node): \"\"\" Returns the node with the smallest key that is greater than or equal to the given value 'key' \"\"\" if node is None: return None if key &lt; node.key: # Ceiling is either in left subtree or is this node attempt_in_left = self._ceiling_node(key, node.left) if attempt_in_left is None: return node else: return attempt_in_left elif key &gt; node.key: # Ceiling must be in right subtree return self._ceiling_node(key, node.right) else: # Keys are equal so ceiling is node with this key return node 参考文献 &lt;&lt;算法导论第三版&gt;&gt; http://algs4.cs.princeton.edu/32bst/","categories":[{"name":"python","slug":"python","permalink":"http://wangshub.github.io/categories/python/"},{"name":"code","slug":"python/code","permalink":"http://wangshub.github.io/categories/python/code/"},{"name":"algorithm","slug":"python/code/algorithm","permalink":"http://wangshub.github.io/categories/python/code/algorithm/"}],"tags":[{"name":"python","slug":"python","permalink":"http://wangshub.github.io/tags/python/"},{"name":"code","slug":"code","permalink":"http://wangshub.github.io/tags/code/"},{"name":"algorithm","slug":"algorithm","permalink":"http://wangshub.github.io/tags/algorithm/"}]},{"title":"python的webrtc库实现语音端点检测","slug":"python-vad","date":"2017-05-25T13:47:56.000Z","updated":"2017-07-13T03:28:54.662Z","comments":true,"path":"2017/05/25/python-vad/","link":"","permalink":"http://wangshub.github.io/2017/05/25/python-vad/","excerpt":"刚刚搭了博客thinkhard.tech,欢迎踩踩~ 引言语音端点检测最早应用于电话传输和检测系统当中,用于通信信道的时间分配,提高传输线路的利用效率.端点检测属于语音处理系统的前端操作,在语音检测领域意义重大.但是目前的语音端点检测,尤其是检测 人声 开始和结束的端点始终是属于技术难点,各家公司始终处于 能判断,但是不敢保证 判别准确性 的阶段.现在基于云端语义库的聊天机器人层出不穷,其中最著名的当属amazon的 Alexa/Echo 智能音箱. 国内如雨后春笋般出现了各种搭载语音聊天的智能音箱(如前几天在知乎上广告的若琪机器人)和各类智能机器人产品.国内语音服务提供商主要面对中文语音服务,由于语音不像图像有分辨率等等较为客观的指标,很多时候凭主观判断,所以较难判断各家语音识别和合成技术的好坏.但是我个人认为,国内的中文语音服务和国外的英文语音服务,在某些方面已经有超越的趋势. 通常搭建机器人聊天系统主要包括以下三个方面: 语音转文字(ASR/STT) 语义内容(NLU/NLP) 文字转语音(TTS) 语音转文字(ASR/STT)在将语音传给云端API之前,是本地前端的语音采集,这部分主要包括如下几个方面: 麦克风降噪 声源定位 回声消除 唤醒词 语音端点检测 音频格式压缩","text":"刚刚搭了博客thinkhard.tech,欢迎踩踩~ 引言语音端点检测最早应用于电话传输和检测系统当中,用于通信信道的时间分配,提高传输线路的利用效率.端点检测属于语音处理系统的前端操作,在语音检测领域意义重大.但是目前的语音端点检测,尤其是检测 人声 开始和结束的端点始终是属于技术难点,各家公司始终处于 能判断,但是不敢保证 判别准确性 的阶段.现在基于云端语义库的聊天机器人层出不穷,其中最著名的当属amazon的 Alexa/Echo 智能音箱. 国内如雨后春笋般出现了各种搭载语音聊天的智能音箱(如前几天在知乎上广告的若琪机器人)和各类智能机器人产品.国内语音服务提供商主要面对中文语音服务,由于语音不像图像有分辨率等等较为客观的指标,很多时候凭主观判断,所以较难判断各家语音识别和合成技术的好坏.但是我个人认为,国内的中文语音服务和国外的英文语音服务,在某些方面已经有超越的趋势. 通常搭建机器人聊天系统主要包括以下三个方面: 语音转文字(ASR/STT) 语义内容(NLU/NLP) 文字转语音(TTS) 语音转文字(ASR/STT)在将语音传给云端API之前,是本地前端的语音采集,这部分主要包括如下几个方面: 麦克风降噪 声源定位 回声消除 唤醒词 语音端点检测 音频格式压缩 python 端点检测由于实际应用中,单纯依靠能量检测特征检测等方法很难判断人声说话的起始点,所以市面上大多数的语音产品都是使用唤醒词判断语音起始.另外加上声音回路,还可以做语音打断.这样的交互方式可能有些傻,每次必须喊一下 唤醒词 才能继续聊天.这种方式聊多了,个人感觉会嘴巴疼:-O .现在github上有snowboy唤醒词的开源库,大家可以登录snowboy官网训练自己的唤醒词模型. Kitt-AI : Snowboy Sensory : Sensory 考虑到用唤醒词嘴巴会累,所以大致调研了一下,python拥有丰富的库,直接import就能食用.这种方式容易受强噪声干扰,适合一个人在家玩玩. pyaudio: pip install pyaudio 可以从设备节点读取原始音频流数据,音频编码是PCM格式; webrtcvad: pip install webrtcvad 检测判断一组语音数据是否为空语音;当检测到持续时间长度 T1 vad检测都有语音活动,可以判定为语音起始;当检测到持续时间长度 T2 vad检测都没有有语音活动,可以判定为语音结束; 完整程序代码可以从我的github下载程序很简单,相信看一会儿就明白了 ''' Requirements: + pyaudio - `pip install pyaudio` + py-webrtcvad - `pip install webrtcvad` ''' import webrtcvad import collections import sys import signal import pyaudio from array import array from struct import pack import wave import time FORMAT = pyaudio.paInt16 CHANNELS = 1 RATE = 16000 CHUNK_DURATION_MS = 30 # supports 10, 20 and 30 (ms) PADDING_DURATION_MS = 1500 # 1 sec jugement CHUNK_SIZE = int(RATE * CHUNK_DURATION_MS / 1000) # chunk to read CHUNK_BYTES = CHUNK_SIZE * 2 # 16bit = 2 bytes, PCM NUM_PADDING_CHUNKS = int(PADDING_DURATION_MS / CHUNK_DURATION_MS) # NUM_WINDOW_CHUNKS = int(240 / CHUNK_DURATION_MS) NUM_WINDOW_CHUNKS = int(400 / CHUNK_DURATION_MS) # 400 ms/ 30ms ge NUM_WINDOW_CHUNKS_END = NUM_WINDOW_CHUNKS * 2 START_OFFSET = int(NUM_WINDOW_CHUNKS * CHUNK_DURATION_MS * 0.5 * RATE) vad = webrtcvad.Vad(1) pa = pyaudio.PyAudio() stream = pa.open(format=FORMAT, channels=CHANNELS, rate=RATE, input=True, start=False, # input_device_index=2, frames_per_buffer=CHUNK_SIZE) got_a_sentence = False leave = False def handle_int(sig, chunk): global leave, got_a_sentence leave = True got_a_sentence = True def record_to_file(path, data, sample_width): \"Records from the microphone and outputs the resulting data to 'path'\" # sample_width, data = record() data = pack('&lt;' + ('h' * len(data)), *data) wf = wave.open(path, 'wb') wf.setnchannels(1) wf.setsampwidth(sample_width) wf.setframerate(RATE) wf.writeframes(data) wf.close() def normalize(snd_data): \"Average the volume out\" MAXIMUM = 32767 # 16384 times = float(MAXIMUM) / max(abs(i) for i in snd_data) r = array('h') for i in snd_data: r.append(int(i * times)) return r signal.signal(signal.SIGINT, handle_int) while not leave: ring_buffer = collections.deque(maxlen=NUM_PADDING_CHUNKS) triggered = False voiced_frames = [] ring_buffer_flags = [0] * NUM_WINDOW_CHUNKS ring_buffer_index = 0 ring_buffer_flags_end = [0] * NUM_WINDOW_CHUNKS_END ring_buffer_index_end = 0 buffer_in = '' # WangS raw_data = array('h') index = 0 start_point = 0 StartTime = time.time() print(\"* recording: \") stream.start_stream() while not got_a_sentence and not leave: chunk = stream.read(CHUNK_SIZE) # add WangS raw_data.extend(array('h', chunk)) index += CHUNK_SIZE TimeUse = time.time() - StartTime active = vad.is_speech(chunk, RATE) sys.stdout.write('1' if active else '_') ring_buffer_flags[ring_buffer_index] = 1 if active else 0 ring_buffer_index += 1 ring_buffer_index %= NUM_WINDOW_CHUNKS ring_buffer_flags_end[ring_buffer_index_end] = 1 if active else 0 ring_buffer_index_end += 1 ring_buffer_index_end %= NUM_WINDOW_CHUNKS_END # start point detection if not triggered: ring_buffer.append(chunk) num_voiced = sum(ring_buffer_flags) if num_voiced &gt; 0.8 * NUM_WINDOW_CHUNKS: sys.stdout.write(' Open ') triggered = True start_point = index - CHUNK_SIZE * 20 # start point # voiced_frames.extend(ring_buffer) ring_buffer.clear() # end point detection else: # voiced_frames.append(chunk) ring_buffer.append(chunk) num_unvoiced = NUM_WINDOW_CHUNKS_END - sum(ring_buffer_flags_end) if num_unvoiced &gt; 0.90 * NUM_WINDOW_CHUNKS_END or TimeUse &gt; 10: sys.stdout.write(' Close ') triggered = False got_a_sentence = True sys.stdout.flush() sys.stdout.write('\\n') # data = b''.join(voiced_frames) stream.stop_stream() print(\"* done recording\") got_a_sentence = False # write to file raw_data.reverse() for index in range(start_point): raw_data.pop() raw_data.reverse() raw_data = normalize(raw_data) record_to_file(\"recording.wav\", raw_data, 2) leave = True stream.close() 程序运行方式sudo python vad.pyqrcode_for_gh_3586401957c4_258.jpg Remove","categories":[{"name":"Python","slug":"Python","permalink":"http://wangshub.github.io/categories/Python/"},{"name":"Code","slug":"Python/Code","permalink":"http://wangshub.github.io/categories/Python/Code/"}],"tags":[{"name":"Code","slug":"Code","permalink":"http://wangshub.github.io/tags/Code/"}]},{"title":"Atom editor","slug":"Atom-editor","date":"2017-05-25T13:27:42.000Z","updated":"2017-07-13T03:28:54.652Z","comments":true,"path":"2017/05/25/Atom-editor/","link":"","permalink":"http://wangshub.github.io/2017/05/25/Atom-editor/","excerpt":"网上一直存在着vim和emacs两大阵营，两边的拥护者把这两个编辑器说的神乎其神。私以为，只是工具而已，对个人来说好用就行。Atom使用下来，我的感受就是 易安装，上手容易 插件安装方便 配置可备份 Atom的安装我的系统是ubuntu16.04,直接官网下载*.deb安装包，运行dpkg -i atom.deb. Atom插件Atom下的插件安装十分便捷，在install a package下就能搜索安装。但是GUI的安装方式常常会安装失败，建议终端使用apm install PackageName安装插件。下面是我安装的一些插件： highlight-selected 代码高亮插件； terminal-fusionAtom下的终端插件，强烈推荐，再也不用切换屏幕运行终端程序了； simplified-chinese-menu：简体中文插件； 待补充。。。 Atom配置Atom自带的插件就能满足基本的日常需求，我能记起来的配置 Markdown文件预览：快捷键Ctl-Shift-m； 文件树，快捷键：ctrl-\\； 文件查找：ctrl-F当前buffer中查找，ctrl-shift-f当前工程中查找； 代码跳转：首先首先ctrl-alt-g生成.tags文件，选中待跳转的函数，ctrl-shift-r完成跳转； alt键隐藏菜单栏，对于笔记本太有用了，整个界面也变得清爽； Atom备份经常在windows和Linux下进行切换，对于我常常作死把系统搞崩，所以需要备份Atom编辑器的配置，和emacs类似，可以将配置～/.atom/文件目录上传github,新装Atom的时候直接clone下来就好，我的配置github地址在这里 最后，上一张我的Atom效果图 Screenshot from 2017-05-25 21-29-45.png","text":"网上一直存在着vim和emacs两大阵营，两边的拥护者把这两个编辑器说的神乎其神。私以为，只是工具而已，对个人来说好用就行。Atom使用下来，我的感受就是 易安装，上手容易 插件安装方便 配置可备份 Atom的安装我的系统是ubuntu16.04,直接官网下载*.deb安装包，运行dpkg -i atom.deb. Atom插件Atom下的插件安装十分便捷，在install a package下就能搜索安装。但是GUI的安装方式常常会安装失败，建议终端使用apm install PackageName安装插件。下面是我安装的一些插件： highlight-selected 代码高亮插件； terminal-fusionAtom下的终端插件，强烈推荐，再也不用切换屏幕运行终端程序了； simplified-chinese-menu：简体中文插件； 待补充。。。 Atom配置Atom自带的插件就能满足基本的日常需求，我能记起来的配置 Markdown文件预览：快捷键Ctl-Shift-m； 文件树，快捷键：ctrl-\\； 文件查找：ctrl-F当前buffer中查找，ctrl-shift-f当前工程中查找； 代码跳转：首先首先ctrl-alt-g生成.tags文件，选中待跳转的函数，ctrl-shift-r完成跳转； alt键隐藏菜单栏，对于笔记本太有用了，整个界面也变得清爽； Atom备份经常在windows和Linux下进行切换，对于我常常作死把系统搞崩，所以需要备份Atom编辑器的配置，和emacs类似，可以将配置～/.atom/文件目录上传github,新装Atom的时候直接clone下来就好，我的配置github地址在这里 最后，上一张我的Atom效果图 Screenshot from 2017-05-25 21-29-45.png","categories":[{"name":"Tool","slug":"Tool","permalink":"http://wangshub.github.io/categories/Tool/"},{"name":"Linux","slug":"Tool/Linux","permalink":"http://wangshub.github.io/categories/Tool/Linux/"}],"tags":[{"name":"Editor","slug":"Editor","permalink":"http://wangshub.github.io/tags/Editor/"}]},{"title":"Cmake 模板","slug":"Cmake-tutorial","date":"2017-05-24T16:03:34.000Z","updated":"2017-07-13T03:28:54.652Z","comments":true,"path":"2017/05/25/Cmake-tutorial/","link":"","permalink":"http://wangshub.github.io/2017/05/25/Cmake-tutorial/","excerpt":"","text":"由于之前的代码Cmake写的比较混乱，库链接的不规范，今天花了一些时间，重写Cmakelist.txt，方便后来的开发。可以根据我的模板开始进行C/C++的项目开发.主要分下面几个方面 更新CMakeList.txt文件 改变头文件位置，索引文件夹 上传新的gitlab CMakeList.txt模板全局CMakeList.txt文件123456789101112131415161718192021222324252627# CMake 最低版本号要求cmake_minimum_required (VERSION 2.8)# 项目信息project (aelos1s)# sys dirfind_package (Threads)# 查找目录下的所有源文件# 并将名称保存到 DIR_SRCS 变量aux_source_directory(. DIR_SRCS)# 添加 math 子目录add_subdirectory(math)add_subdirectory(lib)# 指定生成目标add_executable(aelos $&#123;DIR_SRCS&#125;)# 添加链接库# 生成链接库target_link_libraries(aelos aeloslib)# 多线程链接库target_link_libraries (aelos $&#123;CMAKE_THREAD_LIBS_INIT&#125;) 头文件库CMakeList.txt文件123456# 查找当前目录下的所有源文件# 并将名称保存到 DIR_LIB_SRCS 变量aux_source_directory(. DIR_LIB_SRCS)# 指定生成 aeloslib 链接库add_library (aeloslib $&#123;DIR_LIB_SRCS&#125;) 工程目录结构the file structure is |----main.cpp #主程序 |----lib/ #*.cpp and *.h |----build/ #可执行文件生成文件夹 工程参考模板的github地址 https://github.com/wangshub/cmake","categories":[{"name":"Programming","slug":"Programming","permalink":"http://wangshub.github.io/categories/Programming/"},{"name":"Linux","slug":"Programming/Linux","permalink":"http://wangshub.github.io/categories/Programming/Linux/"},{"name":"c/c++","slug":"Programming/Linux/c-c","permalink":"http://wangshub.github.io/categories/Programming/Linux/c-c/"}],"tags":[{"name":"Code","slug":"Code","permalink":"http://wangshub.github.io/tags/Code/"},{"name":"Linux","slug":"Linux","permalink":"http://wangshub.github.io/tags/Linux/"}]},{"title":"Hello World","slug":"hello-world","date":"2017-04-14T13:28:12.000Z","updated":"2017-12-14T13:47:18.945Z","comments":true,"path":"2017/04/14/hello-world/","link":"","permalink":"http://wangshub.github.io/2017/04/14/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}