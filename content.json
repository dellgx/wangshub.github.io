{"meta":{"title":"神奇的战士","subtitle":"这个不辣～","description":null,"author":"神奇的战士","url":"http://wangshub.github.io"},"pages":[{"title":"categories","date":"2017-12-14T12:05:43.000Z","updated":"2017-12-14T13:21:55.069Z","comments":true,"path":"categories/index.html","permalink":"http://wangshub.github.io/categories/index.html","excerpt":"","text":""},{"title":"about","date":"2017-12-14T11:58:09.712Z","updated":"2017-12-14T11:58:09.712Z","comments":false,"path":"about/index.html","permalink":"http://wangshub.github.io/about/index.html","excerpt":"","text":"hello world"},{"title":"tagcloud","date":"2017-12-14T12:02:28.000Z","updated":"2017-12-14T13:21:25.414Z","comments":true,"path":"tags/index.html","permalink":"http://wangshub.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"python：将图片转换成excel文档","slug":"image-to-excel","date":"2017-12-14T13:28:12.000Z","updated":"2017-12-14T13:37:39.573Z","comments":true,"path":"2017/12/14/image-to-excel/","link":"","permalink":"http://wangshub.github.io/2017/12/14/image-to-excel/","excerpt":"","text":"python：将图片转换成excel文档实现步骤 读取图像，获取图像每个像素点的RGB值； 根据每个像素点的RGB值设置excel每个方格的颜色值； 根据像素点的坐标，写入excel文件； 保存退出； 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061from PIL import Imageimport numpy as npimport timeimport matplotlib.pyplot as pltimport xlsxwriterdef get_xy(row, col): table = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' num1 = col / 26 num2 = col % 26 # print num1, num2 if num1 == 0: return table[num2 - 1] + str(row) else: return table[num1-1] + table[num2 - 1] + str(row)def main(): img = np.array(Image.open('whale.jpeg')) # plt.figure(\"whale\") # plt.imshow(img) # plt.show() rows, cols, dims = img.shape print img.shape print img.dtype print img.size print type(img) # print img[188, 188, 0] excel = xlsxwriter.Workbook('image_excel.xlsx') cellformat = excel.add_format(&#123;'bg_color': '#123456', 'font_color': '#654321'&#125;) worksheet1 = excel.add_worksheet() data = [] color = [''] * cols cellcolor = \"\" for i in range(rows): for j in range(cols): # print hex(img[i, j, 0]), hex(img[i, j, 1]), hex(img[i, j, 2]) cellcolor = (hex(img[i, j, 0]) + hex(img[i, j, 1]) + hex(img[i, j, 2])).replace('0x', '') # print cellcolor cellformat = excel.add_format(&#123;'bg_color': '#'+cellcolor, 'font_color': '#'+cellcolor&#125;) # cellformat = excel.add_format(&#123;'bg_color': '#C6EFCE', # 'font_color': '#006100'&#125;) worksheet1.conditional_format(get_xy(i, j), &#123;'type': 'cell', 'criteria': '&lt;', 'value': 50, 'format': cellformat&#125;) # data.append(data_row) excel.close() if __name__ == '__main__': main() # print get_xy(133, 27)","categories":[],"tags":[{"name":"python","slug":"python","permalink":"http://wangshub.github.io/tags/python/"}]},{"title":"Hello World","slug":"hello-world","date":"2017-12-14T11:15:25.998Z","updated":"2017-12-14T11:15:25.998Z","comments":true,"path":"2017/12/14/hello-world/","link":"","permalink":"http://wangshub.github.io/2017/12/14/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"python check hosts update","slug":"python-check-hosts-update","date":"2017-07-20T14:33:15.000Z","updated":"2017-07-20T14:45:58.984Z","comments":true,"path":"2017/07/20/python-check-hosts-update/","link":"","permalink":"http://wangshub.github.io/2017/07/20/python-check-hosts-update/","excerpt":"","text":"用Python检查 hosts 更新最近各种代理纷纷关闭，常见的翻墙方式就剩lantern和更改hosts的方式依旧坚挺，关注了一些更新hosts的git仓库，但是又不想登录网页查看原作者是否有更新。所以这种苦力活就让Python干好了。 hosts地址_hostsinfo.py1hosts_source = [\"https://raw.githubusercontent.com/racaljk/hosts/master/hosts\"] 检查hosts是否有更新_checkhosts.py1234567891011121314151617181920212223242526272829303132333435363738394041424344import urllib2from .hosts_info import *import osimport filecmpdef hosts_download(): if os.path.exists('hosts'): hosts_name = 'hosts_new' else: hosts_name = 'hosts' # todo: overtime detection f = urllib2.urlopen(hosts_source[0]) print \"downloading hosts\" with open(hosts_name, \"wb\") as code: code.write(f.read())def is_hosts_new(): hosts_download() if not os.path.exists('hosts'): print 'oops, hosts not exists' return -1 elif os.path.exists('hosts') and (not os.path.exists('hosts_new')): print 'first run, only one hosts file' return True elif os.path.exists('hosts') and (os.path.exists('hosts_new')): print 'compare hosts &amp; hosts_new' diff_status = filecmp.cmp('hosts', 'hosts_new') if diff_status: print 'same file' os.remove('hosts_new') return False else: print 'diff file' os.remove('hosts') os.rename('hosts_new', \"hosts\") return True else: return -1 主程序调用main.py1234567from check_hosts.check_hosts import *diff_status = is_hosts_new()if diff_status: print \"new hosts !\"else: print 'code: ',diff_status","categories":[{"name":"Python","slug":"Python","permalink":"http://wangshub.github.io/categories/Python/"},{"name":"VPN","slug":"Python/VPN","permalink":"http://wangshub.github.io/categories/Python/VPN/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://wangshub.github.io/tags/Python/"},{"name":"VPN","slug":"VPN","permalink":"http://wangshub.github.io/tags/VPN/"}]},{"title":"python mail sender","slug":"python-mail-sender","date":"2017-07-20T14:22:06.000Z","updated":"2017-07-20T14:30:11.387Z","comments":true,"path":"2017/07/20/python-mail-sender/","link":"","permalink":"http://wangshub.github.io/2017/07/20/python-mail-sender/","excerpt":"","text":"python 发送邮件配置服务器和邮箱 mail_info.py123456mail_host = 'smtp.yeah.net'mail_user = 'mail_name'mail_pass = 'mail_password'sender = 'mail_name@yeah.net'receivers = ['target@mail.com'] 发送邮件 mail_trans.py1234567891011121314151617181920212223from .mail_info import *import smtplibfrom email.mime.text import MIMETextdef mail_text_send(title, text): message = MIMEText(text, 'plain', 'utf-8') message['Subject'] = title message['From'] = sender message['To'] = receivers[0] try: smtpObj = smtplib.SMTP() # connect host smtpObj.connect(mail_host, 25) # login host smtpObj.login(mail_user, mail_pass) # send smtpObj.sendmail(sender, receivers, message.as_string()) # quit smtpObj.quit() return True except smtplib.SMTPException as e: return False 主程序调用 main.py12from mail_trans import *mail_text_send('title', 'hello world!')","categories":[{"name":"Python","slug":"Python","permalink":"http://wangshub.github.io/categories/Python/"},{"name":"Code","slug":"Python/Code","permalink":"http://wangshub.github.io/categories/Python/Code/"},{"name":"Mail","slug":"Python/Code/Mail","permalink":"http://wangshub.github.io/categories/Python/Code/Mail/"}],"tags":[{"name":"Code","slug":"Code","permalink":"http://wangshub.github.io/tags/Code/"},{"name":"Python","slug":"Python","permalink":"http://wangshub.github.io/tags/Python/"},{"name":"Mail","slug":"Mail","permalink":"http://wangshub.github.io/tags/Mail/"}]},{"title":"使用python备份博客图床图片","slug":"use-python-to-backup-markdown-images","date":"2017-06-05T15:09:29.000Z","updated":"2017-06-05T15:31:18.000Z","comments":true,"path":"2017/06/05/use-python-to-backup-markdown-images/","link":"","permalink":"http://wangshub.github.io/2017/06/05/use-python-to-backup-markdown-images/","excerpt":"","text":"说明最近在写markdown文档的过程中,经常需要插入一些图片.因为托管博客的服务器空间有限,所以上传图片到图床再插入到markdown中.有时候又插入网上的图片,这些图片随时可能失效.导致我的博客网站显示图片错误.所以花了一点时间,用python 正则匹配 markdown中图片链接,然后下载图片保存到本地文件夹img中.这样就不用担心图片失效啦,当我找到稳定的图床,可以随时把这些图片再上传更新,美滋滋~~~ 功能 .md文件自动搜索 正则匹配图片链接 爬取图片内容 保存文本到本地 步骤读取文件 =&gt; 正则匹配 =&gt; 图片下载 =&gt; 保存本地 python代码详细见我的github地址: www.github.com/wangshub 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051# coding=utf-8import sysimport osimport reimport requestsimport urllibimport urllib2def search(path, word): for filename in os.listdir(path): fp = os.path.join(path, filename) if os.path.isfile(fp) and word in filename: print fp download(str(fp)) elif os.path.isdir(fp): search(fp, word)def download(file_path): # filename = \"test\" name = file_path.split(u\"/\") filename = name[-1] f_md = open(file_path) # all text of md file text = f_md.read().decode('utf-8') # regex img_reg = r'\\!&#123;1&#125;\\[(.*?)\\]\\((.*?)\\)' result = re.findall('!\\[(.*)\\]\\((.*)\\)', text) for i in range(len(result)): img_quote = result[i][0] img_url = result[i][1] # download img request = urllib2.Request(img_url) response = urllib2.urlopen(request) img_contents = response.read() # img name spell urlname = img_url.split(u\"/\") img_name = filename + '_' + \\ str(i) + '_' + img_quote + str(urlname[len(urlname) - 1]) print img_name, '~~~', img_url # write to file f_img = open('img/' + img_name, 'wb') f_img.write(img_contents) f_img.close() f_md.close()search(sys.argv[1], '.md') 食用方法python md_image_bacup.py /path/to/your/file/ 作者 Author : WangSongE-mail : easternslope@yeah.net","categories":[{"name":"python","slug":"python","permalink":"http://wangshub.github.io/categories/python/"},{"name":"markdown","slug":"python/markdown","permalink":"http://wangshub.github.io/categories/python/markdown/"},{"name":"code","slug":"python/markdown/code","permalink":"http://wangshub.github.io/categories/python/markdown/code/"}],"tags":[{"name":"python","slug":"python","permalink":"http://wangshub.github.io/tags/python/"},{"name":"code","slug":"code","permalink":"http://wangshub.github.io/tags/code/"},{"name":"markdown","slug":"markdown","permalink":"http://wangshub.github.io/tags/markdown/"}]},{"title":"从机sshfs访问主机文件系统","slug":"sshfs-mount-net-disk","date":"2017-05-31T13:16:00.000Z","updated":"2017-05-31T14:57:30.000Z","comments":true,"path":"2017/05/31/sshfs-mount-net-disk/","link":"","permalink":"http://wangshub.github.io/2017/05/31/sshfs-mount-net-disk/","excerpt":"","text":"说明需要在PC主机(Linux)上编写代码,每次都要将代码拷贝到从机(Linux)上编译运行程序.这里用到scp命令 scp -r /主机/文件 从机名@192.168.x.x:从机目录/.利用sshfs可以直接在从机进行编译,省略拷贝步骤. 系统结构框图Linux 主机 &lt;=====&gt; Linux 从机 操作步骤 主机 sudo apt-get install openssh-server ifconfig -a获取局域网内 IP地址 从机 sudo apt-get install sshfs sshfs -o idmap=user -o reconnect host_name@192.168.20.236:/path/to/your/workspace /path/to/your/workspace 现在可以从从机开心地访问主机文件了 author : Wangsongmail : easternslope@yeah.net","categories":[{"name":"linux","slug":"linux","permalink":"http://wangshub.github.io/categories/linux/"},{"name":"tool","slug":"linux/tool","permalink":"http://wangshub.github.io/categories/linux/tool/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://wangshub.github.io/tags/linux/"},{"name":"tool","slug":"tool","permalink":"http://wangshub.github.io/tags/tool/"}]},{"title":"python 数据结构之二叉搜索树","slug":"python-data-structure-BST","date":"2017-05-29T15:06:12.000Z","updated":"2017-07-13T03:28:54.652Z","comments":true,"path":"2017/05/29/python-data-structure-BST/","link":"","permalink":"http://wangshub.github.io/2017/05/29/python-data-structure-BST/","excerpt":"","text":"二叉搜索树定义一颗二叉搜索树是以二叉树来组织的,每个节点除了 Key 还包括 左孩子, 右孩子, 父节点 等信息. BST满足限制条件: 对于任意节点的X,他的 左子树中关键字最大值&lt;=X.key , 右子树关键字最小值&gt;=X.key 这个关系表示如下 二叉 根据上图定义,一个二叉搜索树的例子是 二叉树操作 查询 插入 删除 查询(搜索)二叉树搜索采用递归的方式来进行查询,根据二叉搜索树的定义: 左子树存储小值, 右子树存储大值,一个完整的二叉搜索示意图如下 可以写成 伪代码 1234567TREE-SEARCH(x, k) if x == NULL or k == x.key return x if k &lt; x.key return TREE-SEARCH(x.left) if k &gt; x.key return TREE-SEARCH(x.right) 转换成python代码 12345678910111213141516171819def _get(self, key, node): if node is None: return None if key &lt; node.key: return self._get(key, node.left) elif key &gt; node.key: return self._get(key, node.right) else: return node.valdef get(self, key): \"\"\" Return the value paired with 'key' Worst Case Complexity: O(N) Balanced Tree Complexity: O(lg N) \"\"\" return self._get(key, self.root) 插入插入和删除比查询呢稍微复杂一些,因为该操作会引起二叉搜索树的大小变化,会改变动态集合的结构.插入呢又比删除稍微容易实现.插入分为两部 查询插入节点 改变目标节点附近的数据结构 插入过程示意图如下 相应的伪代码如下, 输入节点 z , z.key = v, z.left = NULL, z.right = NULL. 12345678910111213141516TREE-INSERT(T, x) y = NULL x = T.root # 从根节点开始 while x != NULL y = x # 保存上一节点 if z.key &lt; x.key # 往左 x = x.left else # 往右 x = x.right z.p = y # 父节点 if y == NULL # tree T 为空 T.root = z else if z.key &lt; y.key y.left = z else y.right = z 程序的运行复杂度取决于二叉树的形状 插入的运行时间取决于二叉搜索树的高度h,程序的运行时间O(h) ,所以二叉树形状的好坏直接影响算法的运行时间. python代码实现为 123456789101112131415161718192021222324252627def _put(self, key, val, node): # If we hit the end of a branch, create a new node if node is None: return Node(key, val) # Follow left branch if key &lt; node.key: node.left = self._put(key, val, node.left) # Follow right branch elif key &gt; node.key: node.right = self._put(key, val, node.right) # Overwrite value else: node.val = val node.size_of_subtree = self._size(node.left) + self._size(node.right)+1 return nodedef put(self, key, val): \"\"\" Add a new key-value pair. Worst Case Complexity: O(N) Balanced Tree Complexity: O(lg N) \"\"\" self.root = self._put(key, val, self.root) 删除删除总共分为三种情况: 如果删除节点x没有孩子,直接删除即可; 如果删除节点x有1个孩子,用孩子替换该节点位置; 如果删除节点x有2个孩子, 这个情况有些复杂.关键是要找到节点 x的继承者 . 节点z的继承者在节点z的右子树中有最小的关键值.这种情况下的操作分为下面步骤: 输入待删除的节点x 和 二叉搜索树T. 在节点x的右子树开始搜索:往右再往左找到最小值节点H; H右孩子为H的父节点, H的左孩子为X的左孩子; 示意图如下,应该一目了然: ](http://algs4.cs.princeton.edu/32bst/images/bst-deletemin.png) ![ 根据上面的描述,删除的伪代码可以分为两部分: 为了移动子树, 用一棵子树替换一棵子树,并成为双亲的孩子节点. 123456789TRANSPLANT(T, u, v)if u.p == NULLT.root = velse if u = u.p.leftu.p.left = velse u.p.right = vif v!= NULLv.p = u.p 根据第一步完成二叉搜索树的删除过程: 1234567891011121314TREE-DELETE(T, z)if z.left = NULLTRANSPLANT(T, z, z.right)else if (z.right == NULL)TRANSPLANT(T, z, z.left)elsey = TREE-MINIMUM(z.right)if y.p != zTRANSPLANT(T, y, y.right)y.right = z.righty.right.p = yTRANSPLANT(T, z, y)y.left = z.lefty.left.p = y 用python 实现如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748def _delete(self, key, node): if node is None: return None if key &lt; node.key: node.left = self._delete(key, node.left) elif key &gt; node.key: node.right = self._delete(key, node.right) else: if node.right is None: return node.left elif node.left is None: return node.right else: old_node = node node = self._ceiling_node(key, node.right) node.right = self._delete_min(old_node.right) node.left = old_node.left node.size_of_subtree = self._size(node.left) + self._size(node.right)+1 return nodedef _delete_min(self, node): if node.left is None: return node.right node.left = self._delete_min(node.left) node.size_of_subtree = self._size(node.left) + self._size(node.right)+1 return nodedef _ceiling_node(self, key, node): \"\"\" Returns the node with the smallest key that is greater than or equal to the given value 'key' \"\"\" if node is None: return None if key &lt; node.key: # Ceiling is either in left subtree or is this node attempt_in_left = self._ceiling_node(key, node.left) if attempt_in_left is None: return node else: return attempt_in_left elif key &gt; node.key: # Ceiling must be in right subtree return self._ceiling_node(key, node.right) else: # Keys are equal so ceiling is node with this key return node 参考文献 &lt;&lt;算法导论第三版&gt;&gt; http://algs4.cs.princeton.edu/32bst/","categories":[{"name":"python","slug":"python","permalink":"http://wangshub.github.io/categories/python/"},{"name":"code","slug":"python/code","permalink":"http://wangshub.github.io/categories/python/code/"},{"name":"algorithm","slug":"python/code/algorithm","permalink":"http://wangshub.github.io/categories/python/code/algorithm/"}],"tags":[{"name":"python","slug":"python","permalink":"http://wangshub.github.io/tags/python/"},{"name":"code","slug":"code","permalink":"http://wangshub.github.io/tags/code/"},{"name":"algorithm","slug":"algorithm","permalink":"http://wangshub.github.io/tags/algorithm/"}]},{"title":"python的webrtc库实现语音端点检测","slug":"python-vad","date":"2017-05-25T13:47:56.000Z","updated":"2017-07-13T03:28:54.662Z","comments":true,"path":"2017/05/25/python-vad/","link":"","permalink":"http://wangshub.github.io/2017/05/25/python-vad/","excerpt":"刚刚搭了博客thinkhard.tech,欢迎踩踩~ 引言语音端点检测最早应用于电话传输和检测系统当中,用于通信信道的时间分配,提高传输线路的利用效率.端点检测属于语音处理系统的前端操作,在语音检测领域意义重大.但是目前的语音端点检测,尤其是检测 人声 开始和结束的端点始终是属于技术难点,各家公司始终处于 能判断,但是不敢保证 判别准确性 的阶段.现在基于云端语义库的聊天机器人层出不穷,其中最著名的当属amazon的 Alexa/Echo 智能音箱. 国内如雨后春笋般出现了各种搭载语音聊天的智能音箱(如前几天在知乎上广告的若琪机器人)和各类智能机器人产品.国内语音服务提供商主要面对中文语音服务,由于语音不像图像有分辨率等等较为客观的指标,很多时候凭主观判断,所以较难判断各家语音识别和合成技术的好坏.但是我个人认为,国内的中文语音服务和国外的英文语音服务,在某些方面已经有超越的趋势. 通常搭建机器人聊天系统主要包括以下三个方面: 语音转文字(ASR/STT) 语义内容(NLU/NLP) 文字转语音(TTS) 语音转文字(ASR/STT)在将语音传给云端API之前,是本地前端的语音采集,这部分主要包括如下几个方面: 麦克风降噪 声源定位 回声消除 唤醒词 语音端点检测 音频格式压缩","text":"刚刚搭了博客thinkhard.tech,欢迎踩踩~ 引言语音端点检测最早应用于电话传输和检测系统当中,用于通信信道的时间分配,提高传输线路的利用效率.端点检测属于语音处理系统的前端操作,在语音检测领域意义重大.但是目前的语音端点检测,尤其是检测 人声 开始和结束的端点始终是属于技术难点,各家公司始终处于 能判断,但是不敢保证 判别准确性 的阶段.现在基于云端语义库的聊天机器人层出不穷,其中最著名的当属amazon的 Alexa/Echo 智能音箱. 国内如雨后春笋般出现了各种搭载语音聊天的智能音箱(如前几天在知乎上广告的若琪机器人)和各类智能机器人产品.国内语音服务提供商主要面对中文语音服务,由于语音不像图像有分辨率等等较为客观的指标,很多时候凭主观判断,所以较难判断各家语音识别和合成技术的好坏.但是我个人认为,国内的中文语音服务和国外的英文语音服务,在某些方面已经有超越的趋势. 通常搭建机器人聊天系统主要包括以下三个方面: 语音转文字(ASR/STT) 语义内容(NLU/NLP) 文字转语音(TTS) 语音转文字(ASR/STT)在将语音传给云端API之前,是本地前端的语音采集,这部分主要包括如下几个方面: 麦克风降噪 声源定位 回声消除 唤醒词 语音端点检测 音频格式压缩 python 端点检测由于实际应用中,单纯依靠能量检测特征检测等方法很难判断人声说话的起始点,所以市面上大多数的语音产品都是使用唤醒词判断语音起始.另外加上声音回路,还可以做语音打断.这样的交互方式可能有些傻,每次必须喊一下 唤醒词 才能继续聊天.这种方式聊多了,个人感觉会嘴巴疼:-O .现在github上有snowboy唤醒词的开源库,大家可以登录snowboy官网训练自己的唤醒词模型. Kitt-AI : Snowboy Sensory : Sensory 考虑到用唤醒词嘴巴会累,所以大致调研了一下,python拥有丰富的库,直接import就能食用.这种方式容易受强噪声干扰,适合一个人在家玩玩. pyaudio: pip install pyaudio 可以从设备节点读取原始音频流数据,音频编码是PCM格式; webrtcvad: pip install webrtcvad 检测判断一组语音数据是否为空语音;当检测到持续时间长度 T1 vad检测都有语音活动,可以判定为语音起始;当检测到持续时间长度 T2 vad检测都没有有语音活动,可以判定为语音结束; 完整程序代码可以从我的github下载程序很简单,相信看一会儿就明白了 ''' Requirements: + pyaudio - `pip install pyaudio` + py-webrtcvad - `pip install webrtcvad` ''' import webrtcvad import collections import sys import signal import pyaudio from array import array from struct import pack import wave import time FORMAT = pyaudio.paInt16 CHANNELS = 1 RATE = 16000 CHUNK_DURATION_MS = 30 # supports 10, 20 and 30 (ms) PADDING_DURATION_MS = 1500 # 1 sec jugement CHUNK_SIZE = int(RATE * CHUNK_DURATION_MS / 1000) # chunk to read CHUNK_BYTES = CHUNK_SIZE * 2 # 16bit = 2 bytes, PCM NUM_PADDING_CHUNKS = int(PADDING_DURATION_MS / CHUNK_DURATION_MS) # NUM_WINDOW_CHUNKS = int(240 / CHUNK_DURATION_MS) NUM_WINDOW_CHUNKS = int(400 / CHUNK_DURATION_MS) # 400 ms/ 30ms ge NUM_WINDOW_CHUNKS_END = NUM_WINDOW_CHUNKS * 2 START_OFFSET = int(NUM_WINDOW_CHUNKS * CHUNK_DURATION_MS * 0.5 * RATE) vad = webrtcvad.Vad(1) pa = pyaudio.PyAudio() stream = pa.open(format=FORMAT, channels=CHANNELS, rate=RATE, input=True, start=False, # input_device_index=2, frames_per_buffer=CHUNK_SIZE) got_a_sentence = False leave = False def handle_int(sig, chunk): global leave, got_a_sentence leave = True got_a_sentence = True def record_to_file(path, data, sample_width): \"Records from the microphone and outputs the resulting data to 'path'\" # sample_width, data = record() data = pack('&lt;' + ('h' * len(data)), *data) wf = wave.open(path, 'wb') wf.setnchannels(1) wf.setsampwidth(sample_width) wf.setframerate(RATE) wf.writeframes(data) wf.close() def normalize(snd_data): \"Average the volume out\" MAXIMUM = 32767 # 16384 times = float(MAXIMUM) / max(abs(i) for i in snd_data) r = array('h') for i in snd_data: r.append(int(i * times)) return r signal.signal(signal.SIGINT, handle_int) while not leave: ring_buffer = collections.deque(maxlen=NUM_PADDING_CHUNKS) triggered = False voiced_frames = [] ring_buffer_flags = [0] * NUM_WINDOW_CHUNKS ring_buffer_index = 0 ring_buffer_flags_end = [0] * NUM_WINDOW_CHUNKS_END ring_buffer_index_end = 0 buffer_in = '' # WangS raw_data = array('h') index = 0 start_point = 0 StartTime = time.time() print(\"* recording: \") stream.start_stream() while not got_a_sentence and not leave: chunk = stream.read(CHUNK_SIZE) # add WangS raw_data.extend(array('h', chunk)) index += CHUNK_SIZE TimeUse = time.time() - StartTime active = vad.is_speech(chunk, RATE) sys.stdout.write('1' if active else '_') ring_buffer_flags[ring_buffer_index] = 1 if active else 0 ring_buffer_index += 1 ring_buffer_index %= NUM_WINDOW_CHUNKS ring_buffer_flags_end[ring_buffer_index_end] = 1 if active else 0 ring_buffer_index_end += 1 ring_buffer_index_end %= NUM_WINDOW_CHUNKS_END # start point detection if not triggered: ring_buffer.append(chunk) num_voiced = sum(ring_buffer_flags) if num_voiced &gt; 0.8 * NUM_WINDOW_CHUNKS: sys.stdout.write(' Open ') triggered = True start_point = index - CHUNK_SIZE * 20 # start point # voiced_frames.extend(ring_buffer) ring_buffer.clear() # end point detection else: # voiced_frames.append(chunk) ring_buffer.append(chunk) num_unvoiced = NUM_WINDOW_CHUNKS_END - sum(ring_buffer_flags_end) if num_unvoiced &gt; 0.90 * NUM_WINDOW_CHUNKS_END or TimeUse &gt; 10: sys.stdout.write(' Close ') triggered = False got_a_sentence = True sys.stdout.flush() sys.stdout.write('\\n') # data = b''.join(voiced_frames) stream.stop_stream() print(\"* done recording\") got_a_sentence = False # write to file raw_data.reverse() for index in range(start_point): raw_data.pop() raw_data.reverse() raw_data = normalize(raw_data) record_to_file(\"recording.wav\", raw_data, 2) leave = True stream.close() 程序运行方式sudo python vad.pyqrcode_for_gh_3586401957c4_258.jpg Remove","categories":[{"name":"Python","slug":"Python","permalink":"http://wangshub.github.io/categories/Python/"},{"name":"Code","slug":"Python/Code","permalink":"http://wangshub.github.io/categories/Python/Code/"}],"tags":[{"name":"Code","slug":"Code","permalink":"http://wangshub.github.io/tags/Code/"}]},{"title":"Atom editor","slug":"Atom-editor","date":"2017-05-25T13:27:42.000Z","updated":"2017-07-13T03:28:54.652Z","comments":true,"path":"2017/05/25/Atom-editor/","link":"","permalink":"http://wangshub.github.io/2017/05/25/Atom-editor/","excerpt":"网上一直存在着vim和emacs两大阵营，两边的拥护者把这两个编辑器说的神乎其神。私以为，只是工具而已，对个人来说好用就行。Atom使用下来，我的感受就是 易安装，上手容易 插件安装方便 配置可备份 Atom的安装我的系统是ubuntu16.04,直接官网下载*.deb安装包，运行dpkg -i atom.deb. Atom插件Atom下的插件安装十分便捷，在install a package下就能搜索安装。但是GUI的安装方式常常会安装失败，建议终端使用apm install PackageName安装插件。下面是我安装的一些插件： highlight-selected 代码高亮插件； terminal-fusionAtom下的终端插件，强烈推荐，再也不用切换屏幕运行终端程序了； simplified-chinese-menu：简体中文插件； 待补充。。。 Atom配置Atom自带的插件就能满足基本的日常需求，我能记起来的配置 Markdown文件预览：快捷键Ctl-Shift-m； 文件树，快捷键：ctrl-\\； 文件查找：ctrl-F当前buffer中查找，ctrl-shift-f当前工程中查找； 代码跳转：首先首先ctrl-alt-g生成.tags文件，选中待跳转的函数，ctrl-shift-r完成跳转； alt键隐藏菜单栏，对于笔记本太有用了，整个界面也变得清爽； Atom备份经常在windows和Linux下进行切换，对于我常常作死把系统搞崩，所以需要备份Atom编辑器的配置，和emacs类似，可以将配置～/.atom/文件目录上传github,新装Atom的时候直接clone下来就好，我的配置github地址在这里 最后，上一张我的Atom效果图 Screenshot from 2017-05-25 21-29-45.png","text":"网上一直存在着vim和emacs两大阵营，两边的拥护者把这两个编辑器说的神乎其神。私以为，只是工具而已，对个人来说好用就行。Atom使用下来，我的感受就是 易安装，上手容易 插件安装方便 配置可备份 Atom的安装我的系统是ubuntu16.04,直接官网下载*.deb安装包，运行dpkg -i atom.deb. Atom插件Atom下的插件安装十分便捷，在install a package下就能搜索安装。但是GUI的安装方式常常会安装失败，建议终端使用apm install PackageName安装插件。下面是我安装的一些插件： highlight-selected 代码高亮插件； terminal-fusionAtom下的终端插件，强烈推荐，再也不用切换屏幕运行终端程序了； simplified-chinese-menu：简体中文插件； 待补充。。。 Atom配置Atom自带的插件就能满足基本的日常需求，我能记起来的配置 Markdown文件预览：快捷键Ctl-Shift-m； 文件树，快捷键：ctrl-\\； 文件查找：ctrl-F当前buffer中查找，ctrl-shift-f当前工程中查找； 代码跳转：首先首先ctrl-alt-g生成.tags文件，选中待跳转的函数，ctrl-shift-r完成跳转； alt键隐藏菜单栏，对于笔记本太有用了，整个界面也变得清爽； Atom备份经常在windows和Linux下进行切换，对于我常常作死把系统搞崩，所以需要备份Atom编辑器的配置，和emacs类似，可以将配置～/.atom/文件目录上传github,新装Atom的时候直接clone下来就好，我的配置github地址在这里 最后，上一张我的Atom效果图 Screenshot from 2017-05-25 21-29-45.png","categories":[{"name":"Tool","slug":"Tool","permalink":"http://wangshub.github.io/categories/Tool/"},{"name":"Linux","slug":"Tool/Linux","permalink":"http://wangshub.github.io/categories/Tool/Linux/"}],"tags":[{"name":"Editor","slug":"Editor","permalink":"http://wangshub.github.io/tags/Editor/"}]},{"title":"Cmake 模板","slug":"Cmake-tutorial","date":"2017-05-24T16:03:34.000Z","updated":"2017-07-13T03:28:54.652Z","comments":true,"path":"2017/05/25/Cmake-tutorial/","link":"","permalink":"http://wangshub.github.io/2017/05/25/Cmake-tutorial/","excerpt":"","text":"由于之前的代码Cmake写的比较混乱，库链接的不规范，今天花了一些时间，重写Cmakelist.txt，方便后来的开发。可以根据我的模板开始进行C/C++的项目开发.主要分下面几个方面 更新CMakeList.txt文件 改变头文件位置，索引文件夹 上传新的gitlab CMakeList.txt模板全局CMakeList.txt文件123456789101112131415161718192021222324252627# CMake 最低版本号要求cmake_minimum_required (VERSION 2.8)# 项目信息project (aelos1s)# sys dirfind_package (Threads)# 查找目录下的所有源文件# 并将名称保存到 DIR_SRCS 变量aux_source_directory(. DIR_SRCS)# 添加 math 子目录add_subdirectory(math)add_subdirectory(lib)# 指定生成目标add_executable(aelos $&#123;DIR_SRCS&#125;)# 添加链接库# 生成链接库target_link_libraries(aelos aeloslib)# 多线程链接库target_link_libraries (aelos $&#123;CMAKE_THREAD_LIBS_INIT&#125;) 头文件库CMakeList.txt文件123456# 查找当前目录下的所有源文件# 并将名称保存到 DIR_LIB_SRCS 变量aux_source_directory(. DIR_LIB_SRCS)# 指定生成 aeloslib 链接库add_library (aeloslib $&#123;DIR_LIB_SRCS&#125;) 工程目录结构the file structure is |----main.cpp #主程序 |----lib/ #*.cpp and *.h |----build/ #可执行文件生成文件夹 工程参考模板的github地址 https://github.com/wangshub/cmake","categories":[{"name":"Programming","slug":"Programming","permalink":"http://wangshub.github.io/categories/Programming/"},{"name":"Linux","slug":"Programming/Linux","permalink":"http://wangshub.github.io/categories/Programming/Linux/"},{"name":"c/c++","slug":"Programming/Linux/c-c","permalink":"http://wangshub.github.io/categories/Programming/Linux/c-c/"}],"tags":[{"name":"Code","slug":"Code","permalink":"http://wangshub.github.io/tags/Code/"},{"name":"Linux","slug":"Linux","permalink":"http://wangshub.github.io/tags/Linux/"}]}]}